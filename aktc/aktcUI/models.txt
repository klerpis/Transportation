import uuid
import datetime
# from functools import partial
from django.db import models
from django.conf import settings
from django.utils import timezone
# from django.db import DataError
from django.core import checks, exceptions, validators
from django.utils.translation import gettext_lazy as _
# from django.contrib.admin.templates import admin


class Customer(models.Model):
    firstname = models.CharField(max_length=45)
    middlename = models.CharField(max_length=45, null=True, blank=True)
    surname = models.CharField(max_length=45, null=True, blank=True)
    phone_number = models.CharField(max_length=15, null=True, blank=True)
    email = models.EmailField(null=False, blank=False)

    def __str__(self):
        return f"{self.firstname}  || {self.email} "


class Driver(models.Model):
    driver_name = models.ForeignKey(
        settings.AUTH_USER_MODEL, verbose_name="Driver's Name", on_delete=models.CASCADE)
    driver_phonenumber = models.CharField(
        "Driver's Phone Number", max_length=18, null=False, blank=False)
    email = models.EmailField(null=False, blank=False)
    passport = models.ImageField(null=True, blank=True)  # not compulsory yet

    def __str__(self):
        return f'{self.driver_name} || Email: {self.email}'


class Bus(models.Model):
    BUS_STATUS_CHOICES = [
        ("RN", "Running"),
        ("DW", "Down"),
    ]
    registration_number = models.CharField(max_length=40)
    bus_name = models.CharField(max_length=20, default='company bus new')
    bus_seat_num = models.CharField(max_length=3, default=1)
    bus_status = models.CharField(
        choices=BUS_STATUS_CHOICES, default=BUS_STATUS_CHOICES[0][1])

    def __str__(self):
        return f'{self.bus_name} || {self.registration_number}'


class BusDetail(models.Model):
    bus = models.ForeignKey(Bus, on_delete=models.DO_NOTHING)
    bus_driver = models.ForeignKey(Driver, on_delete=models.DO_NOTHING,
                                   blank=True, null=True)

    def __str__(self):
        return f'{self.bus.bus_name} || {self.bus.registration_number} || {self.bus.bus_status} || Driver: {self.bus_driver}'


class Location(models.Model):
    state = models.CharField(max_length=20)
    local_government = models.CharField(max_length=45)
    bus_stop = models.CharField(max_length=30)
    street = models.CharField(max_length=30, null=True, blank=True)

    def __str__(self):
        return f'State: {self.state} || LG: {self.local_government} -- bus stop: {self.bus_stop} || street: {(self.street or "")}'


class DepartureTime(models.Model):
    MERIDIAN_CHOICE = {
        "AM": 'am',
        "PM": 'pm'
    }
    HOUR_RANGE_CHOICE = {f"0{i}": f"0{i}" for i in range(0, 10)}
    HOUR_RANGE_CHOICE.update({f"{i}": f"{i}" for i in range(10, 13)})
    MINUTE_RANGE_CHOICE = {
        f"0{i}": f"0{i}" for i in range(0, 10) if i % 5 == 0}
    MINUTE_RANGE_CHOICE.update(
        {f"{i}": f"{i}" for i in range(10, 60) if i % 5 == 0})

    hour = models.CharField(choices=HOUR_RANGE_CHOICE,
                            default=list(HOUR_RANGE_CHOICE.keys())[0])
    minute = models.CharField(
        choices=MINUTE_RANGE_CHOICE, default=list(MINUTE_RANGE_CHOICE.keys())[0])
    meridian = models.CharField(
        choices=MERIDIAN_CHOICE, default=MERIDIAN_CHOICE["AM"])

    def __str__(self):
        return f"Time: {self.hour}:{self.minute}{self.meridian} ||"


class DailyScheduleTime(models.Model):
    time = models.ManyToManyField(
        DepartureTime, related_name='daily_schedule_time')

    def __str__(self):
        return f'{" || ".join([f"{i.hour}.{i.minute}{i.meridian}" for i in self.time.all()])}'


'no coverage for those days yet, please pick a closer date'


class WeekDaysSchedule(models.Model):

    def validate_start_date(start_date):  # cant be in the past
        cant_schedule_into_the_past = start_date > datetime.date.today() - \
            datetime.timedelta(hours=24, minutes=59, seconds=59)
        if (not cant_schedule_into_the_past):
            raise exceptions.ValidationError("Cannot schedule for past days")

    start_or_only_date = models.DateField(
        verbose_name="Start/Only date", default=timezone.now(), unique=True, validators=[validate_start_date,])
    end_date = models.DateField(blank=True, null=True, unique=True)
    daily_schedule = models.ForeignKey(
        DailyScheduleTime, on_delete=models.DO_NOTHING, default='8')

    def __str__(self):
        week: dict[int, str] = {
            0: 'Mon',
            1: 'Tue',
            2: 'Wed',
            3: 'Thur',
            4: 'Fri',
            5: 'Sat',
            6: 'Sun',
        }
        week_index = datetime.datetime.weekday(self.start_or_only_date)

        return f'Day: {str(week[week_index]).center(10, " ")} || Dates: {self.start_or_only_date} || Departure Times: {self.daily_schedule}'

    def clean(self):  # for end date validation
        if self.end_date is not None:
            if not (self.start_or_only_date < self.end_date):
                raise exceptions.ValidationError({
                    'end_date': _("End date cannot be before start date")})

        if self.end_date:
            # num of days inbetween
            days = abs((self.start_or_only_date - self.end_date).days)
            self.previous_date_list = []
            for day_count in range(days+1):
                previous_day_date = self.end_date - \
                    datetime.timedelta(days=day_count)
                if self.start_or_only_date == previous_day_date:
                    continue  # no need to add again
                default = WeekDaysSchedule.objects.filter(
                    start_or_only_date=previous_day_date)
                if len(default) > 0:
                    raise exceptions.ValidationError(
                        _("Dates in-between start and end date already exist in the database"))

                    # continue  # if date already exsit in database. then ignore
                # if self.end_date == previous_day_date: continue
                self.previous_date_list.append(previous_day_date)

        return super().clean()

    def save(self, force_insert=False, force_update=False, using=None, update_fields=None):
        if self.end_date:
            for previous_day_date in self.previous_date_list:
                new_data = WeekDaysSchedule(
                    start_or_only_date=previous_day_date,
                    daily_schedule=self.daily_schedule)
                new_data.save()
            self.end_date = None  # clear end date
        return super().save(force_insert, force_update, using, update_fields)


class Booking(models.Model):
    STATUS_CHOICES = (("Pending", "pending"), ("Success",
                                               "success"), ("Failed", "failed"),)

    client = models.ForeignKey(
        Customer, on_delete=models.DO_NOTHING, null=True, blank=True)
    firstname = models.CharField(max_length=45, blank=True, null=True)
    middlename = models.CharField(max_length=45, blank=True, null=True)
    surname = models.CharField(max_length=45, blank=True, null=True)
    booking_id = models.CharField(
        max_length=20, unique=True, editable=False, blank=True)

    email = models.EmailField()
    departure_date = models.DateField()
    location_from = models.ForeignKey(Location, verbose_name='From',
                                      on_delete=models.DO_NOTHING, related_name='location_from')
    destination_to = models.ForeignKey(Location, verbose_name="To",
                                       on_delete=models.DO_NOTHING, related_name='destination_to')
    departure_time = models.CharField(max_length=100)
    seats_booked = models.IntegerField(default=1)
    bus_detail = models.ForeignKey(BusDetail, on_delete=models.CASCADE)

    payment_due = models.DateTimeField(null=True, blank=True)
    status = models.CharField(
        max_length=20, choices=STATUS_CHOICES, default=STATUS_CHOICES[0][1])

    book_modified = models.DateTimeField(auto_now_add=True)
    book_created = models.DateTimeField(auto_now=True)

    def __str__(self):
        return f"{self.email} || Departure: {self.departure_date} - {self.departure_time} || Destination: from {self.location_from} to {self.destination_to}"

    def extend_departure_time_due_to_delay(self):
        pass

    def get_departure_dates_choices(self):
        selected_date = datetime.datetime.now()
        selected_date_data = WeekDaysSchedule.objects.filter(
            start_or_only_date=selected_date).first()
        scheduled_times_per_day = dict()
        if selected_date_data:
            for depart_time in selected_date_data.daily_schedule.time.all():
                format_time = f'{depart_time.hour}:{depart_time.minute}{depart_time.meridian}'
                scheduled_times_per_day[format_time] = format_time
        return scheduled_times_per_day

    def save(self, *args, **kwargs):
        if not self.booking_id:
            # Create your custom format here
            date_part = datetime.date.today().strftime("%Y%m%d")
            random_part = uuid.uuid4().hex[:5].upper()
            self.booking_id = f"BOOK-{date_part}-{random_part}"
        super().save(*args, **kwargs)


class Feedback(models.Model):

    user = models.ForeignKey(Customer, on_delete=models.CASCADE)
    comment = models.TextField(blank=True)
    rating = models.PositiveIntegerField()  # e.g. 1â€“5 stars
    submitted_at = models.DateTimeField(auto_now_add=True)
    trip_books = models.ForeignKey(Booking, on_delete=models.CASCADE)

    class Meta:
        ordering = ['-submitted_at']

    def is_valid_window(self):
        return timezone.now() <= self.booking.departure_date + datetime.timedelta(hours=48)

    def __str__(self):
        return f"Feedback for {self.booking.booking_id}"


class Review(models.Model):
    name = models.CharField(max_length=100)
    email = models.EmailField(blank=True)
    rating = models.PositiveIntegerField()
    comment = models.TextField()
    published = models.BooleanField(default=False)  # admin approves
    submitted_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"Review by {self.name}"


class PaymentMethod(models.Model):
    name = models.CharField(max_length=45)
    is_default = models.BooleanField(default=False)
    reference = models.CharField(max_length=85, null=True, blank=True)

    def __str__(self):
        return self.name


class Payment(models.Model):

    STATUS_CHOICES = (("Pending", "pending"), ("Success",
                      "success"), ("Failed", "failed"), )

    booking = models.OneToOneField(Booking, on_delete=models.CASCADE)
    amount = models.DecimalField(max_digits=6, decimal_places=3)
    payment_date = models.DateTimeField()
    payment_method = models.ForeignKey(
        PaymentMethod, on_delete=models.SET_NULL, null=True, blank=True)
    reference = models.CharField(max_length=30, blank=True, null=True)
    status = models.CharField(
        max_length=20, choices=STATUS_CHOICES, default=STATUS_CHOICES[0][1])

    def __str__(self):
        return self.booking.__str__()

    def save(self, *args, **kwargs):
        if not self.reference:
            today = timezone.now().strftime('%Y%m%d')
            rand = uuid.uuid4().hex[:5].upper()
            self.reference = f"PAY-{today}-{rand}"
        super().save(*args, **kwargs)

